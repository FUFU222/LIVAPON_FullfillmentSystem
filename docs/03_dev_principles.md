# Development Principles – Impact & Verification

## 1. 動作保証の徹底
- **具体的シナリオ検証**: すべての変更は抽象目標ではなく、具体的なユーザーシナリオ（例: Shopify で注文キャンセル → Console の通知カードが 1 件増える）を完了条件とする。
- **リグレッションケース管理**: 過去に発生したバグはリグレッションテストケースとして再現ログを残し、修正後も再検証を必須とする。
- **成果物は「動く機能」**: git push 後は必ず実際の操作手順とログ（例: API レスポンス、UI スクリーンショット）を添えて動作確認を報告する。

## 2. 影響分析と責務の明確化
- **コンポーネント責務の確認**: 修正前に webhook-processor.ts / orders-realtime-listener.tsx / supabase migrations など各コンポーネントの責務を再確認し、範囲外の副作用を避ける。
- **依存関係の報告**: Webhook → Supabase → Realtime → UI のようなデータフローを明示し、変更がどの部分に連鎖的な動作を起こすかを報告する。
- **Blast Radius を最小化**: Feature flag、段階リリース、テーブル単位のマイグレーションなどで被害範囲を小さく保つ。

## 3. プロセスとフィードバックの形式化
- **ゼロトラスト報告**: 「○○しました」という自己申告ではなく、必ずログ／レスポンス／スクリーンショットといった証拠を添えて作業完了を報告する。
- **失敗からの学習**: エラー発生時には原因・教訓を短くまとめ、次のコーディングで同じミスを防ぐ仕組みに反映する。

## 実務運用
1. 変更前に Impact Analysis（影響範囲、責務、Blast Radius）を記述。
2. 実装後にリグレッションケースを含む具体的シナリオで動作検証し、ログやスクリーンショットを添付。
3. Pull Request / レビューでも同じ観点（Impact Scope / Regression Prevention / Evidence）を必須項目とする。
4. Slack / Docs / issue テンプレートでも上記の原則に沿ったレポート形式を徹底する。
